import aves.*

describe "Intro a Bloques" {
	const sumarUno = { x => x + 1 }
	
	test "Si se usa sumarUno con 5, retorna 6" {
		assert.equals(6, sumarUno.apply(5))
	}	
	test "Si se usa sumarUno con 2, retorna 3" {
		assert.equals(3, sumarUno.apply(2))
	}	
	
	test "Si se usa sumarUno sin parámetros, falla, porque ese bloque espera un parámetro" {
		assert.throwsException({sumarUno.apply()})
	}
	
	test "Si se usa sumarUno con más parámetros de los esperados, falla" {
		assert.throwsException({sumarUno.apply(3,5)})
	}
	
	test "Los bloques son conscientes del contexto en el que fueron creados" {
		var numero = 10
		const bloqueQueUsaNumero = { numero + 32 }
		
		assert.equals(42, bloqueQueUsaNumero.apply())
	}
	
	test "Las referencias variables que existen en el contexto de creación del bloque pueden ser modificadas por el bloque" {
		var numero = 10
		const bloqueQueModificaNumero = { numero += 32 }
		bloqueQueModificaNumero.apply()
		
		assert.equals(42, numero)
	}
	
	test "El mensaje times de los números usa un bloque (con efecto) para saber qué hacer" {
		var numero = 1
		4.times({ i => numero = numero * i })
		assert.equals(24, numero)
	}
	
	// Volvemos a ver el times en acción, ahora haciendo que un ave vuele tantas veces como querramos
	test "Hacer que un ave vuele N veces" {
		const ave = new Ave(energia = 120)
		ave.volaNVeces(7)
		assert.equals(50, ave.energia())
	}
}
